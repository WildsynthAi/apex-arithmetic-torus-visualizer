<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>APEX ARITHMETIC KAM ENGINE // QUANTUM RESONANCE VISUALIZER</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* ================================================= */
/* APEX FUTURISTIC THEME                              */
/* ================================================= */

:root {
  --cyan: #00ffcc;
  --magenta: #ff00aa;
  --void: #000008;
  --deep: #0b0014;
  --glow-cyan: rgba(0, 255, 204, 0.6);
  --glow-magenta: rgba(255, 0, 170, 0.6);
}

html, body {
  margin: 0;
  padding: 0;
  background: var(--void);
  color: var(--cyan);
  font-family: 'Courier New', monospace;
  overflow: hidden;
  height: 100vh;
}

header {
  position: absolute;
  top: 0;
  width: 100%;
  text-align: center;
  padding: 12px 0;
  font-size: 1.4em;
  font-weight: bold;
  letter-spacing: 4px;
  background: linear-gradient(to bottom, rgba(0,255,204,0.15), transparent);
  border-bottom: 1px solid var(--cyan);
  text-shadow: 0 0 15px var(--cyan);
  z-index: 1000;
  animation: pulse 4s infinite alternate;
}

@keyframes pulse {
  from { text-shadow: 0 0 15px var(--cyan); }
  to { text-shadow: 0 0 25px var(--cyan), 0 0 40px var(--cyan); }
}

#wrap {
  display: grid;
  grid-template-columns: 1.6fr 1fr;
  height: 100vh;
  padding-top: 50px;
}

canvas {
  width: 100%;
  height: 100%;
  image-rendering: pixelated; /* Slight crispness */
}

/* Holographic Panels */
.panel {
  position: absolute;
  padding: 18px 22px;
  background: rgba(5, 0, 15, 0.75);
  border: 1px solid;
  border-image: linear-gradient(to bottom, var(--cyan), transparent) 1;
  box-shadow: 0 0 30px var(--glow-cyan), inset 0 0 20px rgba(0,255,204,0.1);
  backdrop-filter: blur(4px);
  font-size: 0.9em;
  letter-spacing: 1px;
  z-index: 100;
  animation: scanline 6s linear infinite;
}

@keyframes scanline {
  0% { background-position: 0 0; }
  100% { background-position: 0 100%; }
}

#tele { top: 70px; right: 20px; border-color: var(--cyan); }
#ctrl { top: 70px; left: 20px; border-color: var(--magenta); }

b {
  display: block;
  margin-bottom: 12px;
  font-size: 1.1em;
  text-shadow: 0 0 10px;
  color: white;
}

label {
  display: flex;
  justify-content: space-between;
  margin: 10px 0;
  color: #88ffff;
}

input {
  width: 70px;
  background: rgba(0,0,0,0.6);
  border: 1px solid var(--magenta);
  color: var(--cyan);
  padding: 6px;
  text-align: center;
  box-shadow: 0 0 15px var(--glow-magenta);
  transition: all 0.3s;
}

input:focus {
  outline: none;
  box-shadow: 0 0 25px var(--magenta);
  background: rgba(255,0,170,0.2);
}

/* Metrics */
.metric {
  display: grid;
  grid-template-columns: 70px 1fr 70px;
  align-items: center;
  margin: 8px 0;
}
.metric-bar {
  height: 8px;
  background: rgba(255,255,255,0.05);
  margin: 0 10px;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 0 10px rgba(0,255,204,0.3);
}
.metric-bar-fill {
  height: 100%;
  transition: width 0.4s ease;
  background: linear-gradient(90deg, var(--cyan), #00ffff);
  box-shadow: 0 0 15px var(--cyan);
}
.label { color: #66ffcc; }
.value { color: var(--cyan); font-weight: bold; text-shadow: 0 0 8px; }

/* Subtle grid overlay */
.grid-overlay {
  position: absolute;
  top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none;
  background: repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(0,255,204,0.03) 20px, rgba(0,255,204,0.03) 40px),
              repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(0,255,204,0.03) 20px, rgba(0,255,204,0.03) 40px);
  z-index: 10;
}
</style>
</head>
<body>

<header>APEX ARITHMETIC KAM ENGINE // QUANTUM RESONANCE CORE</header>
<div class="grid-overlay"></div>

<div id="wrap">
  <canvas id="view"></canvas>
  <canvas id="scan"></canvas>
</div>

<div id="ctrl" class="panel">
  <b>CONTROL MATRIX</b>
  <label>A <input id="A" type="number" value="9" min="1"></label>
  <label>B <input id="B" type="number" value="5" min="0"></label>
  <label>M <input id="M" type="number" value="3" min="2"></label>
</div>

<div id="tele" class="panel">
  <b>TELEMETRY CORE</b>
  <div class="metric"><span class="label">Tick</span><span class="value" id="t">0</span></div>
  <div class="metric"><span class="label">Entropy</span><div class="metric-bar"><div class="metric-bar-fill" id="e_bar"></div></div><span class="value" id="e">0</span></div>
  <div class="metric"><span class="label">Lyapunov</span><div class="metric-bar"><div class="metric-bar-fill" id="l_bar"></div></div><span class="value" id="l">0</span></div>
  <div class="metric"><span class="label">Mean</span><span class="value" id="m">0</span></div>
  <div class="metric"><span class="label">Resonance</span><span class="value" id="r">0</span></div>
</div>

<script>
// ======================== SIMULATOR (unchanged) ========================
class Simulator {
    constructor() {
        this.PHI = (1 + Math.sqrt(5)) / 2;
        this.GOLD = 2 * Math.PI * (1 - 1 / this.PHI);
        this.EPS = 1e-9;
        this.HISTORY_SIZE = 1500;
        this.A = 9; this.B = 5; this.M = 3;
        this.tick = 0; this.hist = []; this.run = 0; this.maxRun = 0; this.lyapSum = 0;
        this.P = [1];
    }
    partMod(n) {
        let M = this.M;
        while (this.P.length <= n) {
            let s = 0, m = this.P.length;
            for (let k = 1; ; k++) {
                let g1 = k * (3 * k - 1) / 2 | 0;
                let g2 = k * (3 * k + 1) / 2 | 0;
                if (g1 > m && g2 > m) break;
                let sign = (k % 2) ? 1 : -1;
                if (g1 <= m) s += sign * this.P[m - g1];
                if (g2 <= m) s += sign * this.P[m - g2];
            }
            this.P.push(((s % M) + M) % M);
        }
        return this.P[n];
    }
    evolve(steps = 1) {
        for (let k = 0; k < steps; k++) {
            let n = this.A * this.tick + this.B;
            let v = this.partMod(n);
            let s = 1 - v / this.M;
            this.hist.push(s);
            if (this.hist.length > this.HISTORY_SIZE) this.hist.shift();
            if (v === 0) { this.run++; this.maxRun = Math.max(this.maxRun, this.run); }
            else this.run = 0;
            this.lyapSum += Math.log(Math.abs(s - 0.5) + this.EPS);
            this.tick++;
        }
        return this.getMetrics();
    }
    getMetrics() {
        let mean = 0, varr = 0;
        this.hist.forEach(x => mean += x);
        mean /= this.hist.length || 1;
        this.hist.forEach(x => varr += (x - mean) ** 2);
        varr /= this.hist.length || 1;
        const ent = Math.sqrt(Math.max(varr, this.EPS));
        const lambda = this.lyapSum / (this.tick || 1);
        return { tick: this.tick, mean, entropy: ent, maxRun: this.maxRun, lambda, hist: this.hist, GOLD: this.GOLD, M: this.M };
    }
    reseed(A, B, M) {
        this.A = A; this.B = B; this.M = M;
        this.P = [1]; this.hist = []; this.tick = 0; this.run = 0; this.maxRun = 0; this.lyapSum = 0;
    }
}

// ======================== RENDERER (upgraded visuals) ========================
class Renderer {
    constructor(sim, viewCanvas, scanCanvas) {
        this.sim = sim;
        this.vctx = viewCanvas.getContext("2d");
        this.sctx = scanCanvas.getContext("2d");
        this.view = viewCanvas;
        this.scan = scanCanvas;
        this.elements = {
            A: document.getElementById("A"), B: document.getElementById("B"), M: document.getElementById("M"),
            t: document.getElementById("t"), m: document.getElementById("m"), e: document.getElementById("e"),
            r: document.getElementById("r"), l: document.getElementById("l"),
            e_bar: document.getElementById("e_bar"), l_bar: document.getElementById("l_bar")
        };
        window.addEventListener("resize", () => this.resize());
        this.elements.A.addEventListener("change", () => this.handleControlChange());
        this.elements.B.addEventListener("change", () => this.handleControlChange());
        this.elements.M.addEventListener("change", () => this.handleControlChange());
        this.resize();
        this.handleControlChange();
    }
    resize() {
        [this.view, this.scan].forEach(c => {
            const r = c.getBoundingClientRect();
            c.width = r.width * devicePixelRatio;
            c.height = r.height * devicePixelRatio;
            c.style.width = r.width + 'px';
            c.style.height = r.height + 'px';
        });
    }
    handleControlChange() {
        const A = +this.elements.A.value || 1;
        const B = +this.elements.B.value || 0;
        const M = Math.max(2, +this.elements.M.value || 2);
        this.sim.reseed(A, B, M);
        this.vctx.clearRect(0, 0, this.view.width, this.view.height);
        this.sctx.clearRect(0, 0, this.scan.width, this.scan.height);
    }
    updateTelemetry(m) {
        this.elements.t.textContent = m.tick;
        this.elements.m.textContent = m.mean.toFixed(4);
        this.elements.e.textContent = m.entropy.toFixed(4);
        this.elements.r.textContent = m.maxRun;
        this.elements.l.textContent = m.lambda.toFixed(4);

        const ent_norm = Math.min(1, m.entropy * 8);
        this.elements.e_bar.style.width = `${ent_norm * 100}%`;
        const ent_col = ent_norm < 0.15 ? '#00ffcc' : ent_norm < 0.4 ? '#a0ff80' : '#ff00aa';
        this.elements.e_bar.style.background = ent_col;
        this.elements.e.style.color = ent_col;

        const lyap_norm = Math.min(1, Math.max(0, (m.lambda + 0.4) / 0.8));
        this.elements.l_bar.style.width = `${lyap_norm * 100}%`;
        const lyap_col = m.lambda < -0.08 ? '#00ffcc' : m.lambda > 0.05 ? '#ff00aa' : '#ffff00';
        this.elements.l_bar.style.background = lyap_col;
        this.elements.l.style.color = lyap_col;
    }
    drawView(m) {
        const { hist, entropy, lambda, mean, GOLD } = m;
        const cx = this.view.width / 2, cy = this.view.height / 2;
        const radiusBase = Math.min(cx, cy) * 0.5;
        const spread = Math.min(cx, cy) * 0.35;

        // Trail fade
        this.vctx.fillStyle = "rgba(0, 0, 15, 0.08)";
        this.vctx.fillRect(0, 0, this.view.width, this.view.height);

        // Draw points with glow
        hist.forEach((s, i) => {
            const deviation = (s - mean) * spread;
            const damping = entropy * spread * 2;
            let r = radiusBase + deviation - damping;
            r = Math.max(10, r);

            const angle = i * GOLD;
            const x = cx + Math.cos(angle) * r;
            const y = cy + Math.sin(angle) * r;

            const hue = (angle * 180 / Math.PI + Date.now() * 0.02) % 360;
            this.vctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
            this.vctx.shadowBlur = 12;
            this.vctx.fillStyle = `hsla(${hue}, 100%, 70%, 0.9)`;
            this.vctx.fillRect(x - 1.5, y - 1.5, 3, 3);
        });
        this.vctx.shadowBlur = 0;

        // Pulsing quantum core
        const stability = Math.max(0, -lambda);
        const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
        const coreGlow = stability > 0.08 ? '#00ffcc' : stability > 0.02 ? '#ffff00' : '#ff00aa';
        const coreSize = 8 + pulse * 20 * stability;

        this.vctx.shadowColor = coreGlow;
        this.vctx.shadowBlur = coreSize * 2;
        this.vctx.fillStyle = coreGlow;
        this.vctx.beginPath();
        this.vctx.arc(cx, cy, 4 + pulse * 4, 0, Math.PI * 2);
        this.vctx.fill();

        // Inner ring glow when very stable
        if (entropy < 0.03) {
            this.vctx.strokeStyle = 'rgba(0,255,204,0.4)';
            this.vctx.lineWidth = 3;
            this.vctx.beginPath();
            this.vctx.arc(cx, cy, radiusBase - damping, 0, Math.PI * 2);
            this.vctx.stroke();
        }
        this.vctx.shadowBlur = 0;
    }
    drawScan(m) {
        const w = this.scan.width, h = this.scan.height;
        this.sctx.fillStyle = "rgba(0,0,15,0.07)";
        this.sctx.fillRect(0, 0, w, h);

        const x = m.tick % w;
        const resonanceStrength = Math.min(1, m.maxRun / (m.M * 8));
        const col = resonanceStrength > 0.7 ? '#00ffcc' : resonanceStrength > 0.3 ? '#00ffff' : '#003322';

        // Resonance spike
        this.sctx.fillStyle = col;
        this.sctx.shadowColor = col;
        this.sctx.shadowBlur = 20;
        this.sctx.fillRect(x, 0, 3, h);
        this.sctx.shadowBlur = 0;

        // Chaos plasma at bottom
        const chaos = Math.min(1, m.entropy * 10);
        this.sctx.fillStyle = `rgba(255, 0, 170, ${chaos * 0.8})`;
        this.sctx.fillRect(x - 1, h - chaos * h * 0.5, 5, chaos * h * 0.5);
    }
}

// ======================== INIT ========================
const sim = new Simulator();
const view = document.getElementById("view");
const scan = document.getElementById("scan");
const renderer = new Renderer(sim, view, scan);

function loop() {
    const metrics = sim.evolve(10);
    renderer.updateTelemetry(metrics);
    renderer.drawView(metrics);
    renderer.drawScan(metrics);
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>